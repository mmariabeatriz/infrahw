$date
	Sun Jul 13 03:30:33 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_control_signals $end
$var wire 2 ! store_size_control [1:0] $end
$var wire 2 " shift_amt_selector [1:0] $end
$var wire 5 # shamt [4:0] $end
$var wire 5 $ rt [4:0] $end
$var wire 5 % rs [4:0] $end
$var wire 1 & reg_write $end
$var wire 1 ' reg_dst $end
$var wire 5 ( rd [4:0] $end
$var wire 1 ) pc_write_cond $end
$var wire 1 * pc_write $end
$var wire 2 + pc_source [1:0] $end
$var wire 6 , opcode [5:0] $end
$var wire 1 - mem_write $end
$var wire 1 . mem_to_reg $end
$var wire 1 / mem_read $end
$var wire 2 0 load_size_control [1:0] $end
$var wire 1 1 jump $end
$var wire 16 2 immediate [15:0] $end
$var wire 6 3 funct [5:0] $end
$var wire 5 4 current_state [4:0] $end
$var wire 1 5 branch $end
$var wire 1 6 alu_zero $end
$var wire 1 7 alu_src $end
$var wire 1 8 alu_overflow $end
$var wire 4 9 alu_op [3:0] $end
$var wire 4 : alu_control [3:0] $end
$var wire 26 ; address [25:0] $end
$var reg 1 < clk $end
$var reg 1 = div_zero $end
$var reg 32 > instruction [31:0] $end
$var reg 1 ? overflow $end
$var reg 1 @ reset $end
$var reg 1 A zero_flag $end
$scope module uut $end
$var wire 1 < clk $end
$var wire 5 B current_state [4:0] $end
$var wire 1 = div_zero $end
$var wire 32 C instruction [31:0] $end
$var wire 1 ? overflow $end
$var wire 1 @ reset $end
$var wire 1 A zero_flag $end
$var parameter 6 D FUNCT_ADD $end
$var parameter 6 E FUNCT_AND $end
$var parameter 6 F FUNCT_DIV $end
$var parameter 6 G FUNCT_JR $end
$var parameter 6 H FUNCT_MFHI $end
$var parameter 6 I FUNCT_MFLO $end
$var parameter 6 J FUNCT_MULT $end
$var parameter 6 K FUNCT_SLL $end
$var parameter 6 L FUNCT_SLT $end
$var parameter 6 M FUNCT_SRA $end
$var parameter 6 N FUNCT_SUB $end
$var parameter 6 O FUNCT_XCHG $end
$var parameter 6 P OP_ADDI $end
$var parameter 6 Q OP_BEQ $end
$var parameter 6 R OP_BNE $end
$var parameter 6 S OP_J $end
$var parameter 6 T OP_JAL $end
$var parameter 6 U OP_LB $end
$var parameter 6 V OP_LUI $end
$var parameter 6 W OP_LW $end
$var parameter 6 X OP_SB $end
$var parameter 6 Y OP_SLLM $end
$var parameter 6 Z OP_SW $end
$var parameter 6 [ OP_TYPE_R $end
$var parameter 5 \ ST_ADD $end
$var parameter 5 ] ST_ADDI $end
$var parameter 5 ^ ST_AND $end
$var parameter 5 _ ST_BEQ $end
$var parameter 5 ` ST_BNE $end
$var parameter 5 a ST_DECODE $end
$var parameter 5 b ST_DIV $end
$var parameter 5 c ST_DIV0 $end
$var parameter 5 d ST_FETCH $end
$var parameter 5 e ST_J $end
$var parameter 5 f ST_JAL $end
$var parameter 5 g ST_JR $end
$var parameter 5 h ST_LB $end
$var parameter 5 i ST_LUI $end
$var parameter 5 j ST_LW $end
$var parameter 5 k ST_MFHI $end
$var parameter 5 l ST_MFLO $end
$var parameter 5 m ST_MULT $end
$var parameter 5 n ST_OPCODE404 $end
$var parameter 5 o ST_OVERFLOW $end
$var parameter 5 p ST_RESET $end
$var parameter 5 q ST_SB $end
$var parameter 5 r ST_SLL $end
$var parameter 5 s ST_SLLM $end
$var parameter 5 t ST_SLT $end
$var parameter 5 u ST_SRA $end
$var parameter 5 v ST_SUB $end
$var parameter 5 w ST_SW $end
$var parameter 5 x ST_XCHG $end
$var reg 26 y address [25:0] $end
$var reg 4 z alu_control [3:0] $end
$var reg 4 { alu_op [3:0] $end
$var reg 1 8 alu_overflow $end
$var reg 1 7 alu_src $end
$var reg 1 6 alu_zero $end
$var reg 1 5 branch $end
$var reg 5 | counter [4:0] $end
$var reg 6 } funct [5:0] $end
$var reg 16 ~ immediate [15:0] $end
$var reg 1 1 jump $end
$var reg 2 !" load_size_control [1:0] $end
$var reg 1 / mem_read $end
$var reg 1 . mem_to_reg $end
$var reg 1 - mem_write $end
$var reg 6 "" opcode [5:0] $end
$var reg 2 #" pc_source [1:0] $end
$var reg 1 * pc_write $end
$var reg 1 ) pc_write_cond $end
$var reg 5 $" rd [4:0] $end
$var reg 1 ' reg_dst $end
$var reg 1 & reg_write $end
$var reg 5 %" rs [4:0] $end
$var reg 5 &" rt [4:0] $end
$var reg 5 '" shamt [4:0] $end
$var reg 2 (" shift_amt_selector [1:0] $end
$var reg 5 )" state [4:0] $end
$var reg 2 *" store_size_control [1:0] $end
$scope task decode_instruction $end
$upscope $end
$scope task handle_add_state $end
$upscope $end
$scope task handle_addi_state $end
$upscope $end
$scope task handle_and_state $end
$upscope $end
$scope task handle_beq_state $end
$upscope $end
$scope task handle_bne_state $end
$upscope $end
$scope task handle_decode_state $end
$upscope $end
$scope task handle_div0_state $end
$upscope $end
$scope task handle_div_state $end
$upscope $end
$scope task handle_fetch_state $end
$upscope $end
$scope task handle_j_state $end
$upscope $end
$scope task handle_jal_state $end
$upscope $end
$scope task handle_jr_state $end
$upscope $end
$scope task handle_lb_state $end
$upscope $end
$scope task handle_lui_state $end
$upscope $end
$scope task handle_lw_state $end
$upscope $end
$scope task handle_mfhi_state $end
$upscope $end
$scope task handle_mflo_state $end
$upscope $end
$scope task handle_mult_state $end
$upscope $end
$scope task handle_opcode404_state $end
$upscope $end
$scope task handle_overflow_state $end
$upscope $end
$scope task handle_reset_state $end
$upscope $end
$scope task handle_sb_state $end
$upscope $end
$scope task handle_sll_state $end
$upscope $end
$scope task handle_sllm_state $end
$upscope $end
$scope task handle_slt_state $end
$upscope $end
$scope task handle_sra_state $end
$upscope $end
$scope task handle_sub_state $end
$upscope $end
$scope task handle_sw_state $end
$upscope $end
$scope task handle_xchg_state $end
$upscope $end
$scope task reset_control_signals $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1110 x
b10111 w
b1101 v
b1100 u
b1011 t
b10010 s
b1010 r
b10110 q
b0 p
b11010 o
b11011 n
b110 m
b1001 l
b1000 k
b10101 j
b10100 i
b10011 h
b111 g
b11001 f
b11000 e
b1 d
b11100 c
b101 b
b10 a
b10001 `
b10000 _
b100 ^
b1111 ]
b11 \
b0 [
b101011 Z
b1 Y
b101000 X
b100011 W
b1111 V
b100000 U
b11 T
b10 S
b101 R
b100 Q
b1000 P
b101 O
b100010 N
b11 M
b101010 L
b0 K
b11000 J
b10010 I
b10000 H
b1000 G
b11010 F
b100100 E
b100000 D
$end
#0
$dumpvars
bx *"
b0 )"
bx ("
b0 '"
b0 &"
b0 %"
b0 $"
bx #"
b0 ""
bx !"
b0 ~
b0 }
bx |
bx {
b0 z
b0 y
b0 C
b0 B
0A
1@
0?
b0 >
0=
0<
b0 ;
b0 :
bx 9
x8
x7
x6
x5
b0 4
b0 3
b0 2
x1
bx 0
x/
x.
x-
b0 ,
bx +
x*
x)
b0 (
x'
x&
b0 %
b0 $
b0 #
bx "
bx !
$end
#5
b0 |
1<
#10
0<
0@
#15
b1 4
b1 B
b1 )"
08
06
b0 "
b0 ("
b0 +
b0 #"
0)
0*
b0 !
b0 *"
b0 0
b0 !"
0&
07
0-
b0 9
b0 {
0.
0/
05
01
0'
1<
#20
b1001010100100000000100000 ;
b1001010100100000000100000 y
b100000000100000 2
b100000000100000 ~
b100000 3
b100000 }
b1000 (
b1000 $"
b1010 $
b1010 &"
b1001 %
b1001 %"
0<
b1001010100100000000100000 >
b1001010100100000000100000 C
#25
b10 4
b10 B
b10 )"
1*
1/
1<
#30
0<
#35
b11 4
b11 B
b11 )"
1<
#40
0<
#45
b10 :
b10 z
b1 4
b1 B
b1 )"
1&
b10 9
b10 {
1'
1<
#50
b10010100000010000000 ;
b10010100000010000000 y
b100000010000000 2
b100000010000000 ~
b0 3
b0 }
b10 #
b10 '"
b1001 $
b1001 &"
b0 %
b0 %"
0<
b10010100000010000000 >
b10010100000010000000 C
#55
b10 4
b10 B
b10 )"
b0 :
b0 z
1*
0&
b0 9
b0 {
1/
0'
1<
#60
0<
#65
b1010 4
b1010 B
b1010 )"
1<
#70
0<
#75
b100 :
b100 z
b1 4
b1 B
b1 )"
b11 "
b11 ("
1&
b100 9
b100 {
1'
1<
#80
b1001010000000000001100100 ;
b1001010000000000001100100 y
b1100100 2
b1100100 ~
b100100 3
b100100 }
b1 #
b1 '"
b0 (
b0 $"
b1000 $
b1000 &"
b1001 %
b1001 %"
b1000 ,
b1000 ""
0<
b100001001010000000000001100100 >
b100001001010000000000001100100 C
#85
b10 4
b10 B
b10 )"
b0 :
b0 z
b0 "
b0 ("
1*
0&
b0 9
b0 {
1/
0'
1<
#90
0<
#95
b1111 4
b1111 B
b1111 )"
1<
#100
0<
#105
b10 :
b10 z
b1 4
b1 B
b1 )"
1&
b10 9
b10 {
17
1<
#110
0<
